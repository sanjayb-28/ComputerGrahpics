/*
 * Original cloud implementation was too random and didn't achieve the expected shape.
 * Used Claude to implement clouds based on the Real-Time Rendering billboards chapter.
 * Pretty much main components of this file are generated by AI.
 */
 
#include "CSCIx229.h"
#include "sky_clouds.h"
#include "landscape.h"

static void setAtmosphericCloudProperties(AtmosphericCloud* cloud, float baseAltitude) {
    cloud->posX = ((float)rand() / RAND_MAX - 0.5f) * LANDSCAPE_SCALE * 1.7f;
    cloud->posZ = ((float)rand() / RAND_MAX - 0.5f) * LANDSCAPE_SCALE * 1.7f;
    cloud->posY = baseAltitude + 48.0f + ((float)rand() / RAND_MAX) * 22.0f;
    cloud->radius = 24.0f + ((float)rand() / RAND_MAX) * 13.0f;
    cloud->opacity = 0.28f + ((float)rand() / RAND_MAX) * 0.23f;
}

AtmosphericCloudSystem* atmosphericCloudSystemCreate(float referenceAltitude) {
    AtmosphericCloudSystem* system = (AtmosphericCloudSystem*)malloc(sizeof(AtmosphericCloudSystem));
    if (!system) return NULL;
    system->numClouds = 88;
    system->baseAltitude = referenceAltitude + 42.0f;
    for (int idx = 0; idx < system->numClouds; idx++) {
        setAtmosphericCloudProperties(&system->cloudBank[idx], system->baseAltitude);
    }
    return system;
}

// Claude generated this function, based on inputs I gave from the realtime rendering book, Billboarding chapter
static void renderAtmosphericCloudLayer(const AtmosphericCloud* cloud, int stratum) {
    float t = (float)stratum / 5.0f;
    float bulge = sinf(t * M_PI) * 1.6f;
    float stratumRadius = cloud->radius * (1.0f - t * 0.22f);
    float stratumOpacity = cloud->opacity * (0.58f - t * 0.11f);
    float stratumAltitude = cloud->posY + bulge * 13.0f;
    
    glBegin(GL_TRIANGLE_FAN);
    glColor4f(1.0f, 1.0f, 1.0f, stratumOpacity);
    glVertex3f(cloud->posX, stratumAltitude + bulge * 2.7f, cloud->posZ);
    
    for (int j = 0; j <= 18; j++) {
        float angle = (float)j / 18 * 2 * M_PI;
        float radialDist = 0.83f + 0.17f * sinf(angle * 2 + cloud->posX * 0.13f);
        float variation = 1.0f + 0.19f * cosf(angle * 3 + cloud->posZ * 0.13f);
        float px = cloud->posX + cosf(angle) * stratumRadius * variation * radialDist;
        float pz = cloud->posZ + sinf(angle) * stratumRadius * variation * radialDist;
        float py = stratumAltitude + bulge * (1.0f - radialDist) * 7.0f + sinf(angle * 2) * bulge * 2.7f;
        glVertex3f(px, py, pz);
    }
    glEnd();
}

static void renderAtmosphericCloud(const AtmosphericCloud* cloud) {
    for (int stratum = 0; stratum < 6; stratum++) {
        renderAtmosphericCloudLayer(cloud, stratum);
    }
}
// claude generated code ends here

void atmosphericCloudSystemRender(AtmosphericCloudSystem* system) {
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glDisable(GL_LIGHTING);
    
    for (int idx = 0; idx < system->numClouds; idx++) {
        renderAtmosphericCloud(&system->cloudBank[idx]);
    }
    
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_LIGHTING);
    glDisable(GL_BLEND);
}

void atmosphericCloudSystemDestroy(AtmosphericCloudSystem* system) {
    if (system) {
        free(system);
    }
}