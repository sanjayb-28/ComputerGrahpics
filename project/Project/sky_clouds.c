/*
 * sky_clouds.c - Procedural Volumetric Cloud System for Boulder Scene
 *
 * This file implements the procedural cloud system for the 3D Boulder-inspired scene.
 * It is responsible for generating, animating, and rendering atmospheric clouds that float above the landscape.
 * The system uses a layered, billboard-based approach to create the illusion of volumetric, soft, and natural-looking clouds.
 *
 * Key Features:
 * - Procedurally generates a bank of clouds, each with randomized position, altitude, size, and opacity for realism.
 * - Each cloud is rendered as a stack of semi-transparent, irregularly-shaped layers (strata) using triangle fans.
 * - Uses mathematical bulging and edge distortion to avoid flat or repetitive shapes, inspired by real-time rendering techniques.
 * - Renders all clouds with alpha blending and disables lighting for a soft, glowing effect that integrates with the sky.
 * - Designed to be modular: the cloud system can be created, rendered, and destroyed independently of other systems.
 *
 * This file is ideal for demoing procedural volumetric cloud rendering, and for answering questions about
 * OpenGL blending, procedural geometry, and modular graphics system design.
 *
 * Original cloud implementation was too random and didn't achieve the expected shape.
 * Used Claude to implement clouds based on the Real-Time Rendering billboards chapter.
 * Pretty much main components of this file are generated by AI.
 */
 
#include "CSCIx229.h"      // Custom OpenGL and utility header
#include "sky_clouds.h"    // Header for cloud system types and prototypes
#include "landscape.h"     // Needed for LANDSCAPE_SCALE

// =========================
// Sets the properties of a single atmospheric cloud instance.
// Randomizes position, altitude, radius, and opacity for natural variety.
// =========================
static void setAtmosphericCloudProperties(AtmosphericCloud* cloud, float baseAltitude) {
    // Each cloud is placed randomly in the XZ plane above the landscape, so the sky looks full and natural.
    cloud->posX = ((float)rand() / RAND_MAX - 0.5f) * LANDSCAPE_SCALE * 1.7f;
    cloud->posZ = ((float)rand() / RAND_MAX - 0.5f) * LANDSCAPE_SCALE * 1.7f;
    // The Y (altitude) is randomized above a base altitude, so clouds form layers at different heights.
    cloud->posY = baseAltitude + 48.0f + ((float)rand() / RAND_MAX) * 22.0f;
    // Each cloud has a random radius, so some are small and wispy, others are large and puffy.
    cloud->radius = 24.0f + ((float)rand() / RAND_MAX) * 13.0f;
    // Opacity is randomized for depth and to avoid uniform, "cut-out" looking clouds.
    cloud->opacity = 0.28f + ((float)rand() / RAND_MAX) * 0.23f;
}

// =========================
// Creates and initializes an atmospheric cloud system with many clouds.
// Each cloud is given randomized properties for a natural sky.
// =========================
AtmosphericCloudSystem* atmosphericCloudSystemCreate(float referenceAltitude) {
    // Allocate memory for the cloud system struct, which holds all clouds.
    AtmosphericCloudSystem* system = (AtmosphericCloudSystem*)malloc(sizeof(AtmosphericCloudSystem));
    if (!system) return NULL; // If allocation fails, return NULL so caller can handle error.
    system->numClouds = 88; // 88 clouds gives a dense, layered sky without overdraw.
    system->baseAltitude = referenceAltitude + 42.0f; // Place clouds well above the terrain.
    // Initialize each cloud with random properties for position, size, and opacity.
    for (int idx = 0; idx < system->numClouds; idx++) {
        setAtmosphericCloudProperties(&system->cloudBank[idx], system->baseAltitude);
    }
    return system;
}

// =========================
// Renders a single cloud layer (stratum) as a triangle fan.
// Each cloud is made of several strata for volume and softness.
// =========================
// Claude generated this function, based on inputs I gave from the realtime rendering book, Billboarding chapter
static void renderAtmosphericCloudLayer(const AtmosphericCloud* cloud, int stratum) {
    // t is a normalized height (0 = bottom, 1 = top) for this stratum in the cloud stack.
    float t = (float)stratum / 5.0f;
    // Bulge uses a sine curve to make the cloud "puff out" in the middle and taper at top/bottom.
    float bulge = sinf(t * M_PI) * 1.6f;
    // Each stratum is slightly smaller than the one below, so the cloud is wider at the base.
    float stratumRadius = cloud->radius * (1.0f - t * 0.22f);
    // Opacity fades out for higher strata, so the cloud looks soft and not like a solid object.
    float stratumOpacity = cloud->opacity * (0.58f - t * 0.11f);
    // The altitude of this stratum is offset by the bulge, so the cloud is not flat.
    float stratumAltitude = cloud->posY + bulge * 13.0f;
    
    glBegin(GL_TRIANGLE_FAN); // Triangle fan: center vertex, then rim vertices in a circle.
    glColor4f(1.0f, 1.0f, 1.0f, stratumOpacity); // White color, alpha for softness and blending.
    glVertex3f(cloud->posX, stratumAltitude + bulge * 2.7f, cloud->posZ); // Center vertex (top of bulge)
    
    for (int j = 0; j <= 18; j++) {
        // Angle around the circle (0 to 2pi), divides the rim into 18 segments for smoothness.
        float angle = (float)j / 18 * 2 * M_PI;
        // Radial distortion: makes the edge wavy and irregular, so clouds don't look like perfect circles.
        float radialDist = 0.83f + 0.17f * sinf(angle * 2 + cloud->posX * 0.13f);
        float variation = 1.0f + 0.19f * cosf(angle * 3 + cloud->posZ * 0.13f);
        // Compute X, Z position for rim vertex, using radius, distortion, and variation.
        float px = cloud->posX + cosf(angle) * stratumRadius * variation * radialDist;
        float pz = cloud->posZ + sinf(angle) * stratumRadius * variation * radialDist;
        // Compute Y position for rim vertex, with bulge and additional vertical variation for "fluffiness".
        float py = stratumAltitude + bulge * (1.0f - radialDist) * 7.0f + sinf(angle * 2) * bulge * 2.7f;
        glVertex3f(px, py, pz); // Add rim vertex to fan
    }
    glEnd(); // Finish drawing this stratum. The result is a soft, semi-transparent cloud layer.
}

// =========================
// Renders all strata of a single cloud for a volumetric effect.
// Each stratum is rendered from bottom to top, so the cloud looks 3D from any angle.
// =========================
static void renderAtmosphericCloud(const AtmosphericCloud* cloud) {
    for (int stratum = 0; stratum < 6; stratum++) {
        renderAtmosphericCloudLayer(cloud, stratum);
    }
}
// claude generated code ends here

// =========================
// Renders the entire atmospheric cloud system (all clouds in the sky).
// Sets OpenGL state for blending and disables lighting for soft, glowing clouds.
// =========================
void atmosphericCloudSystemRender(AtmosphericCloudSystem* system) {
    // Enable alpha blending so clouds can be semi-transparent and overlap naturally.
    glEnable(GL_BLEND); // Enable alpha blending for transparency
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); // Standard alpha blending (source over destination)
    glDisable(GL_LIGHTING); // Clouds are self-lit, not affected by scene lights (they "glow" softly)
    
    // Render each cloud in the system. Each cloud is made of several strata.
    for (int idx = 0; idx < system->numClouds; idx++) {
        renderAtmosphericCloud(&system->cloudBank[idx]); // Draw each cloud
    }
    
    // Restore OpenGL state for the rest of the scene.
    glEnable(GL_DEPTH_TEST); // Restore depth testing for rest of scene
    glEnable(GL_LIGHTING);   // Restore lighting for rest of scene
    glDisable(GL_BLEND);     // Disable blending to avoid affecting other objects
}

// =========================
// Frees the memory used by the cloud system.
// =========================
void atmosphericCloudSystemDestroy(AtmosphericCloudSystem* system) {
    if (system) {
        free(system);
    }
}